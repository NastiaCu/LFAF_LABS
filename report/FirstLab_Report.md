# Topic: Intro to formal languages. Regular grammars. Finite Automata.

### Course: Formal Languages & Finite Automata
### Author: Anastasia Cunev 

----

## Theory
The `Grammar` is a set G which includes Vn, Vt, P and S, where:
* **Vn** is a set of nonterminal symbols
* **Vt** is a set of terminal symbols
* **S** is a starting point
* **P** is a set of productions 
  
**For example:**
   ```c#
    P = s{ 
        S → aB
        S → bB
        B → bD
        D → b
        D → aD
        B → cB
        B → aS
    }
   ```
The language generated by the grammar is denoted **L(G)**.

Having the following set of productions we can generate different words such as: 

```c#
S → aB → abD → abaD → abaaD → abaab
``` 

The `Finite Automaton` is a state machine, which has 5 tuples:
* **Q** is a set of states
* **Σ** is an input alphabet
* **δ** is a set of transitions 
* **q0** is the initial state
* **F** is a set of final states 
  
## Objectives:
1. Understand what a language is and what it needs to have in order to be considered a formal one.

2. Provide the initial setup for the evolving project that you will work on during this semester. I said project because usually at lab works, I encourage/impose students to treat all the labs like stages of development of a whole project. Basically you need to do the following:

    a. Create a local && remote repository of a VCS hosting service (let us all use Github to avoid unnecessary headaches);

    b. Choose a programming language, and my suggestion would be to choose one that supports all the main paradigms;

    c. Create a separate folder where you will be keeping the report. This semester I wish I won't see reports alongside source code files, fingers crossed;

3. According to your variant number (by universal convention it is register ID), get the grammar definition and do the following tasks:

    a. Implement a type/class for your grammar;

    b. Add one function that would generate 5 valid strings from the language expressed by your given grammar;

    c. Implement some functionality that would convert and object of type Grammar to one of type Finite Automaton;
    
    d. For the Finite Automaton, please add a method that checks if an input string can be obtained via the state transition from it;

## Implementation description

To generate 5 valid strings from the grammar I made a `GenerateString()` function, which takes the string with the starting character "S". After that it checks if the string contains non-terminal symbols `{ S, B, D }` and if it finds them, it randomly selects the options for the next characters from the production and adds it to the string to make a word. After that it checks if the final string is termanal and prints the results.

```c#
public void GenerateString(){
        
        Random random = new Random();
        string s = "S";
        
        while (true){
            string word = "";
            

            for (int i = 0; i < s.Length; i++){
                string symbol = s[i].ToString();
                if (VN.Contains(symbol)){
                    List<string> options = P[symbol];
                    int optionIndex = random.Next(options.Count);
                    word += options[optionIndex];
                }
               
                else{
                    word += symbol;
                }
            }

            if (!IsTerminal(word)){
                Console.WriteLine(word);
                s = word;
            }

            else{
                Console.WriteLine("Final result: " + word);
                break;
            }
        }
    }

    private bool IsTerminal(string s){
        
        for (int i = 0; i < s.Length; i++){
            if (!VT.Contains(s[i].ToString())){
                return false;
            }
        }

        return true;
    }
```

The following method converts an object of type `Grammar` to type `Finite Automaton`. To do so we have to transforms the initial variables from the `Grammar` to the ones in the `Fininte Automaton`. We assign "S" as the initial state and "D" as the final state. `VN` set from the `Grammar` is the `states` set in `Fininte Automaton` and `Vt` set is the `alphabet` set. The productions from the set `P` from the `Grammar` are added to the `Transitions` set from the `Finite Automaton`.

```c#
public FiniteAutomaton ToFiniteAutomaton(){

            FiniteAutomaton automaton = new FiniteAutomaton();
            string initialState = "S";
            List<string> finalStates = new List<string>{ "D" };
            
            foreach (string symbol in VN){
                automaton.AddState(symbol);
            }

            foreach (string symbol in VT){
                automaton.AddAlphabet(symbol);
            }

            foreach (KeyValuePair<string, List<string>> production in P){
                
                foreach (string value in production.Value){
                    automaton.AddTransition(production.Key, value);
                }
            }

            automaton.AddInitialState(initialState);

            foreach (string finalState in finalStates){
                automaton.AddFinalState(finalState);
            }

            return automaton;
        }
```

For the Finite Futomaton we have an `isValid()` class, which checks if an input string can be obtained via the state transition from it. Basically, it takes the initial state of the finite automaton and checks every symbol in the input string if it exists in the alphabet (alphabet - set of terminal characters). After that it checks if there is a transition from the current state to the next state (transition from the current state to some state for the current symbol).

```c#
public bool isValid(string input){
        
        string current = initialState;

        foreach (char symbol in input){
            if (!alphabet.Contains(symbol.ToString())){
                return false;
            }

            bool found = true;
            foreach (KeyValuePair<string, List<string>> transition in transitions){
                if (transition.Key == current && transition.Value.Contains(symbol.ToString())){
                    current = transition.Key;
                    found = true;
                    break;
                }
            }

            if (!found){
                return false;
            }
        }

        return true;
    }
```

## Conclusions / Screenshots / Results
After performing this laboratory work I studied what is a language and what it needs to have in order to be considered a formal one. As a result of the work I managed to make classes for `Grammar` and `Finite Automaton`, which have the requred tuples and functions to generate valid strings, make an automaton from grammar and check if a word can be obtained via the state transition.

After running the project we get the following results:
```c#
bB
bbD
Final result: bbb

bB
bbD
Final result: bbb

bB
bcB
bcaS
bcabB
bcabcB
bcabcaS
bcabcaaB
bcabcaaaS
bcabcaaabB
bcabcaaabbD
bcabcaaabbaD
Final result: bcabcaaabbab

aB
acB
acaS
acaaB
acaacB
acaacaS
acaacabB
acaacabcB
acaacabcbD
Final result: acaacabcbb

bB
bbD
bbaD
bbaaD
Final result: bbaab

acbab is a valid string
```

## References 

1. https://github.com/DrVasile/FLFA-Labs
2. https://github.com/DrVasile/FLFA-Labs-Examples
3. https://else.fcim.utm.md/pluginfile.php/110458/mod_resource/content/0/LFPC_Guide.pdf
